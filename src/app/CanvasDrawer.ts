export interface CellDimension {  x: number,  y: number,  xCenter: number,  yCenter: number,  radius: number,  width: number,  height: number}export class CanvasDrawer {  static BORDER: number = 2;   //the border on all four sides of the canvas.  static ROWS: number = 6;     //the number of rows on our board  static COLUMNS: number = 7;  //the number of columns on our board  static CELL_PADDING: number = 3;  static calculateCellDimensions(canvas, columnIndex: number, rowIndex: number): CellDimension {    const cellWidth = ((canvas.width - 2 * this.BORDER) / this.COLUMNS);    const cellHeight = ((canvas.height - 2 * this.BORDER) / this.ROWS);    const x = this.BORDER + columnIndex * cellWidth;    const y = this.BORDER + rowIndex * cellHeight;    return {      x: x,      y: y,      xCenter: x + (cellWidth / 2.0),      yCenter: y + (cellHeight / 2.0),      width: cellWidth,      height: cellHeight,      radius: (Math.min(cellWidth, cellHeight) / 2.0) - this.CELL_PADDING    };  }  static clear(canvas) {    const ctx = canvas.getContext('2d');    ctx.clearRect(0, 0, canvas.width, canvas.height);  }  static drawCell(canvas, x: number, y: number, color?: string): void {    const dimensions = this.calculateCellDimensions(canvas, x, y);    const ctx = canvas.getContext('2d');    ctx.lineWidth = 2;    ctx.strokeStyle = "#086788";    ctx.strokeRect (dimensions.x, dimensions.y, dimensions.width, dimensions.height);    if (color) {      ctx.fillStyle = color;      // if (1 === state) {      //   ctx.fillStyle = "#DD1C1A"; //red      // } else {      //   ctx.fillStyle = "#f6f600"; //yellow      // }      const path = new Path2D();      path.arc(dimensions.xCenter, dimensions.yCenter, dimensions.radius, 0, 2 * Math.PI);      ctx.fill(path);    }  }  static getColumnIndex(width: number, x: number) {    console.log('getColumnIndex', width, this.COLUMNS);    const cellWidth = (width/ this.COLUMNS);    return Math.floor(x / cellWidth);  }}